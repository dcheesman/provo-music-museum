---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Artist Timeline">
  <section class="px-4 py-8">
    <div class="container mx-auto mb-6">
      <h1 class="text-4xl font-bold text-white mb-4">Artist Timeline & Connections</h1>
      <p class="text-gray-400 mb-6 max-w-2xl">
        Artists positioned by their first show at Velour (2006-2026).
        Circle size represents connection count. Click an artist to see who they've played with.
      </p>

      <!-- Controls -->
      <div class="flex flex-wrap gap-4">
        <input
          type="text"
          id="timeline-search"
          placeholder="Search for an artist..."
          class="search-input max-w-md"
        />
        <button id="scroll-to-start" class="bg-gray-800 hover:bg-gray-700 px-4 py-2 rounded-lg">
          Scroll to 2006
        </button>
        <button id="scroll-to-end" class="bg-gray-800 hover:bg-gray-700 px-4 py-2 rounded-lg">
          Scroll to 2026
        </button>
      </div>
    </div>

    <!-- Timeline Container - Horizontal Scroll -->
    <div id="timeline-container" class="timeline-container relative w-full overflow-x-auto overflow-y-visible" style="background-color: #1a1a1a; height: 800px;">
      <div id="timeline-loading" class="absolute inset-0 flex items-center justify-center">
        <span class="text-gray-400">Loading timeline visualization...</span>
      </div>
      <svg id="timeline-svg" style="display: none;"></svg>
      <!-- Tooltip -->
      <div id="tooltip" class="absolute hidden bg-gray-900 text-white px-3 py-2 rounded-lg text-sm pointer-events-none shadow-lg border border-gray-700 z-50">
        <div id="tooltip-name" class="font-bold"></div>
        <div id="tooltip-stats" class="text-gray-400 text-xs"></div>
      </div>
    </div>

    <!-- Legend -->
    <div class="container mx-auto mt-6">
      <div class="flex flex-wrap gap-6 text-sm text-gray-400">
        <div class="flex items-center gap-2">
          <div class="w-4 h-4 rounded-full bg-[#BF0404]"></div>
          <span>High connection count</span>
        </div>
        <div class="flex items-center gap-2">
          <div class="w-4 h-4 rounded-full bg-[#F20505]"></div>
          <span>Medium connection count</span>
        </div>
        <div class="flex items-center gap-2">
          <div class="w-4 h-4 rounded-full bg-[#F87171]"></div>
          <span>Lower connection count</span>
        </div>
        <div class="flex items-center gap-2">
          <div class="w-3 h-2 bg-[#3B82F6] rounded-sm"></div>
          <span>Show marker (hover for details)</span>
        </div>
      </div>
    </div>
  </section>

  <!-- Artist Details Panel -->
  <div id="artist-panel" class="fixed right-0 top-0 h-full w-80 bg-gray-900 border-l border-gray-800 p-6 transform translate-x-full transition-transform z-50 overflow-y-auto">
    <button id="close-panel" class="absolute top-4 right-4 text-gray-500 hover:text-white">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
      </svg>
    </button>
    <h2 id="panel-artist-name" class="text-2xl font-bold text-white mb-4"></h2>
    <div id="panel-stats" class="space-y-2 text-gray-400 mb-6"></div>
    <h3 class="font-bold text-white mb-2">Connections</h3>
    <ul id="panel-connections" class="space-y-1 text-gray-400 max-h-96 overflow-y-auto"></ul>
  </div>
</Layout>

<script>
  import * as d3 from 'd3';

  interface TimelineNode {
    id: string;
    name: string;
    showCount: number;
    connectionCount: number;
    firstShowDate: string;
    x?: number;
    y?: number;
    fy?: number | null;
  }

  interface TimelineLink {
    source: string | TimelineNode;
    target: string | TimelineNode;
    weight: number;
  }

  interface NetworkData {
    nodes: TimelineNode[];
    links: TimelineLink[];
  }

  interface Show {
    id: string;
    date: string;
    title: string;
    genre?: string;
    eventType: string;
    artists: Array<{id: string; name: string; isHeadliner: boolean}>;
    soldOut: boolean;
    ticketPrice?: string;
  }

  let simulation: d3.Simulation<TimelineNode, TimelineLink>;
  let svg: d3.Selection<SVGSVGElement, unknown, HTMLElement, any>;
  let networkData: NetworkData;
  let showsData: Show[] = [];
  let currentZoom = 1;
  let labelsGroup: d3.Selection<SVGGElement, unknown, HTMLElement, any>;
  let linksGroup: d3.Selection<SVGGElement, unknown, HTMLElement, any>;
  let showMarkersGroup: d3.Selection<SVGGElement, unknown, HTMLElement, any>;
  let nodesSelection: d3.Selection<SVGCircleElement, TimelineNode, SVGGElement, unknown>;
  let selectedNode: TimelineNode | null = null;
  let xScale: d3.ScaleTime<number, number>;
  let margin: {top: number; right: number; bottom: number; left: number};

  async function loadNetworkData(): Promise<NetworkData | null> {
    try {
      const response = await fetch('/data/network.json');
      if (response.ok) {
        return await response.json();
      }
    } catch (e) {
      console.error('Failed to load network data:', e);
    }
    return null;
  }

  async function loadShowsData(): Promise<Show[] | null> {
    try {
      const response = await fetch('/data/shows.json');
      if (response.ok) {
        return await response.json();
      }
    } catch (e) {
      console.error('Failed to load shows data:', e);
    }
    return null;
  }

  function initTimeline(data: NetworkData) {
    const container = document.getElementById('timeline-container');
    const loading = document.getElementById('timeline-loading');
    const svgElement = document.getElementById('timeline-svg') as SVGSVGElement;

    if (!container || !svgElement) return;

    loading?.remove();
    svgElement.style.display = 'block';

    // Make the SVG much wider for horizontal scrolling (8x viewport width)
    const viewportWidth = container.clientWidth;
    const width = viewportWidth * 8;
    const height = 800;
    margin = { top: 40, right: 40, bottom: 60, left: 40 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    // Clear existing
    svgElement.innerHTML = '';

    svg = d3.select(svgElement)
      .attr('width', width)
      .attr('height', height);

    // Filter nodes to only those with a valid first show date between 2006-2026
    const validNodes = data.nodes.filter(n => {
      if (!n.firstShowDate) return false;
      const year = parseInt(n.firstShowDate.substring(0, 4));
      return year >= 2006 && year <= 2026;
    });

    // Create time scale for x-axis (2006 to 2026)
    const minDate = new Date('2006-01-01');
    const maxDate = new Date('2026-12-31');

    xScale = d3.scaleTime()
      .domain([minDate, maxDate])
      .range([margin.left, width - margin.right]);

    // Set initial x positions based on first show date
    validNodes.forEach(node => {
      node.x = xScale(new Date(node.firstShowDate));
      node.y = innerHeight / 2 + margin.top; // Start in middle
    });

    // No zoom - just use horizontal scrollbar
    const g = svg.append('g');

    // Scale for node size based on connection count
    const sizeScale = d3.scaleSqrt()
      .domain([1, d3.max(validNodes, d => d.connectionCount) || 50])
      .range([4, 25]);

    // Color scale based on connection count
    const colorScale = d3.scaleSequential()
      .domain([0, d3.max(validNodes, d => d.connectionCount) || 50])
      .interpolator(t => d3.interpolateRgb('#F87171', '#BF0404')(t));

    // Create simulation with collision detection on Y-axis only
    // X positions are locked to the timeline date
    simulation = d3.forceSimulation(validNodes)
      .force('x', d3.forceX<TimelineNode>(d => xScale(new Date(d.firstShowDate))).strength(1))
      .force('y', d3.forceY<TimelineNode>().y(innerHeight / 2 + margin.top).strength(0.02))
      .force('collision', d3.forceCollide<TimelineNode>().radius(d => sizeScale(d.connectionCount) + 2).iterations(3))
      .alphaDecay(0.01);

    // Draw timeline axis
    const xAxis = d3.axisBottom(xScale)
      .ticks(d3.timeYear.every(2))
      .tickFormat(d => d3.timeFormat('%Y')(d as Date));

    g.append('g')
      .attr('class', 'x-axis')
      .attr('transform', `translate(0, ${height - margin.bottom})`)
      .call(xAxis)
      .attr('color', '#666')
      .selectAll('text')
      .attr('fill', '#999');

    // Add grid lines for years
    g.append('g')
      .attr('class', 'grid')
      .selectAll('line')
      .data(d3.timeYear.range(minDate, maxDate, 1))
      .join('line')
      .attr('x1', d => xScale(d))
      .attr('x2', d => xScale(d))
      .attr('y1', margin.top)
      .attr('y2', height - margin.bottom)
      .attr('stroke', '#333')
      .attr('stroke-width', 0.5)
      .attr('stroke-dasharray', '2,2');

    // Create empty links group
    linksGroup = g.append('g').attr('class', 'links');

    // Create show markers group (below nodes)
    showMarkersGroup = g.append('g').attr('class', 'show-markers');

    // Draw nodes
    nodesSelection = g.append('g')
      .selectAll('circle')
      .data(validNodes)
      .join('circle')
      .attr('r', d => sizeScale(d.connectionCount))
      .attr('fill', d => colorScale(d.connectionCount))
      .attr('stroke', '#1a1a1a')
      .attr('stroke-width', 2)
      .attr('class', 'artist-node')
      .attr('cursor', 'pointer')
      .call(d3.drag<SVGCircleElement, TimelineNode>()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended))
      .on('click', (event, d) => {
        event.stopPropagation();
        selectNode(d);
      })
      .on('mouseover', function(event, d) {
        d3.select(this).attr('stroke', '#F0F0F0').attr('stroke-width', 3);
        showTooltip(event, d);
      })
      .on('mousemove', function(event, d) {
        moveTooltip(event);
      })
      .on('mouseout', function(event, d) {
        // Keep white stroke if this is the selected node
        if (selectedNode?.id === d.id) {
          d3.select(this).attr('stroke', '#F0F0F0').attr('stroke-width', 3);
        } else {
          d3.select(this).attr('stroke', '#1a1a1a').attr('stroke-width', 2);
        }
        hideTooltip();
      });

    // Labels removed for performance and clarity
    labelsGroup = g.append('g').attr('class', 'labels');

    // Update positions on tick (only Y changes, X is fixed by date)
    simulation.on('tick', () => {
      // Update link positions if any are drawn
      linksGroup.selectAll('line')
        .attr('x1', (d: any) => d.source.x)
        .attr('y1', (d: any) => d.source.y)
        .attr('x2', (d: any) => d.target.x)
        .attr('y2', (d: any) => d.target.y);

      nodesSelection
        .attr('cx', d => d.x!)
        .attr('cy', d => d.y!);
    });

    networkData = { nodes: validNodes, links: data.links };

    // Click on background to deselect
    svg.on('click', () => {
      clearSelection();
    });
  }

  function selectNode(artist: TimelineNode) {
    // If clicking same node, deselect
    if (selectedNode?.id === artist.id) {
      clearSelection();
      return;
    }

    selectedNode = artist;

    // Helper to get ID from source/target
    const getId = (node: any) => typeof node === 'string' ? node : node.id;

    // Find all connections for this artist
    const artistLinks = networkData.links.filter((l: any) =>
      getId(l.source) === artist.id || getId(l.target) === artist.id
    );

    // Get connected node IDs
    const connectedIds = new Set<string>();
    connectedIds.add(artist.id);
    artistLinks.forEach((l: any) => {
      connectedIds.add(getId(l.source));
      connectedIds.add(getId(l.target));
    });

    // Build a map of node positions
    const nodeMap = new Map<string, TimelineNode>();
    nodesSelection.data().forEach((n: TimelineNode) => nodeMap.set(n.id, n));

    // Draw links for selected node
    linksGroup.selectAll('line').remove();
    linksGroup.selectAll('line')
      .data(artistLinks)
      .join('line')
      .attr('stroke', '#BF0404')
      .attr('stroke-opacity', 0.4)
      .attr('stroke-width', (d: any) => Math.max(1, Math.sqrt(d.weight)))
      .attr('x1', (d: any) => nodeMap.get(getId(d.source))?.x || 0)
      .attr('y1', (d: any) => nodeMap.get(getId(d.source))?.y || 0)
      .attr('x2', (d: any) => nodeMap.get(getId(d.target))?.x || 0)
      .attr('y2', (d: any) => nodeMap.get(getId(d.target))?.y || 0);

    // Draw time active rectangle on date axis FIRST (behind)
    drawTimeActiveBar(artist);

    // Draw show markers SECOND (on top)
    drawShowMarkers(artist);

    // Dim non-connected nodes
    nodesSelection
      .attr('opacity', (d: TimelineNode) => connectedIds.has(d.id) ? 1 : 0.2)
      .attr('stroke', (d: TimelineNode) => d.id === artist.id ? '#F0F0F0' : '#1a1a1a')
      .attr('stroke-width', (d: TimelineNode) => d.id === artist.id ? 3 : 2);

    // Show artist panel
    showArtistPanel(artist);
  }

  function drawTimeActiveBar(artist: TimelineNode) {
    // Find all shows for this artist to determine active period
    const artistShows = showsData.filter(show =>
      show.artists.some(a => a.id === artist.id)
    );

    if (artistShows.length === 0) return;

    // Get first and last show dates
    const dates = artistShows.map(s => new Date(s.date)).sort((a, b) => a.getTime() - b.getTime());
    const firstDate = dates[0];
    const lastDate = dates[dates.length - 1];

    const height = 800; // Fixed height we set
    const yPosition = height - margin.bottom + 16; // Position for the line

    const startX = xScale(firstDate);
    const endX = xScale(lastDate);

    // Draw the time active line - use insert to place it at the beginning (behind markers)
    showMarkersGroup.insert('line', ':first-child')
      .attr('x1', startX)
      .attr('y1', yPosition)
      .attr('x2', endX)
      .attr('y2', yPosition)
      .attr('stroke', '#3B82F6')
      .attr('stroke-width', 4)
      .attr('stroke-opacity', 0.8)
      .attr('class', 'time-active-line');
  }

  function drawShowMarkers(artist: TimelineNode) {
    // Find all shows for this artist
    const artistShows = showsData.filter(show =>
      show.artists.some(a => a.id === artist.id)
    );

    // Clear existing markers and lines (except the time active line which was drawn first)
    showMarkersGroup.selectAll('.show-connection-line').remove();
    showMarkersGroup.selectAll('rect').remove();

    // Draw rectangles at the bottom on top of the time active line
    const markerHeight = 12;
    const markerWidth = 4;
    const height = 800; // Fixed height
    const yPosition = height - margin.bottom + 10; // Position for the markers

    // Build a map of node positions for drawing connection lines
    const nodeMap = new Map<string, TimelineNode>();
    nodesSelection.data().forEach((n: TimelineNode) => nodeMap.set(n.id, n));

    // First, draw connection lines from show markers (at bottom) to other artists
    artistShows.forEach((show: Show) => {
      const showX = xScale(new Date(show.date));
      const showY = yPosition + markerHeight / 2; // Middle of the marker at bottom

      // Find other artists in this show
      show.artists.forEach(showArtist => {
        if (showArtist.id !== artist.id) {
          const otherNode = nodeMap.get(showArtist.id);
          if (otherNode && otherNode.x !== undefined && otherNode.y !== undefined) {
            // Draw line from show marker (at bottom) to other artist
            showMarkersGroup.append('line')
              .attr('x1', showX)
              .attr('y1', showY)
              .attr('x2', otherNode.x)
              .attr('y2', otherNode.y)
              .attr('stroke', '#3B82F6')
              .attr('stroke-opacity', 0.15)
              .attr('stroke-width', 1)
              .attr('class', 'show-connection-line');
          }
        }
      });
    });

    // Then draw show markers on top
    showMarkersGroup.selectAll('rect')
      .data(artistShows)
      .join('rect')
      .attr('x', (d: Show) => xScale(new Date(d.date)) - markerWidth / 2)
      .attr('y', yPosition)
      .attr('width', markerWidth)
      .attr('height', markerHeight)
      .attr('fill', '#3B82F6')
      .attr('opacity', 0.8)
      .attr('rx', 1)
      .style('cursor', 'pointer')
      .on('mouseover', function(event, d: Show) {
        d3.select(this).attr('opacity', 1).attr('fill', '#60A5FA');
        showShowTooltip(event, d);
      })
      .on('mousemove', function(event) {
        moveTooltip(event);
      })
      .on('mouseout', function() {
        d3.select(this).attr('opacity', 0.8).attr('fill', '#3B82F6');
        hideTooltip();
      });
  }

  function showShowTooltip(event: MouseEvent, show: Show) {
    const tooltip = document.getElementById('tooltip');
    const nameEl = document.getElementById('tooltip-name');
    const statsEl = document.getElementById('tooltip-stats');
    const container = document.getElementById('timeline-container');
    if (!tooltip || !nameEl || !statsEl || !container) return;

    const artistNames = show.artists.map(a => a.name).join(', ');
    nameEl.textContent = show.title;
    statsEl.innerHTML = `
      <div>${show.date}</div>
      <div>${artistNames}</div>
      ${show.genre ? `<div>Genre: ${show.genre}</div>` : ''}
      ${show.ticketPrice ? `<div>Price: ${show.ticketPrice}</div>` : ''}
      ${show.soldOut ? '<div class="text-red-400">SOLD OUT</div>' : ''}
    `;
    tooltip.classList.remove('hidden');

    // Position tooltip ABOVE the show marker to avoid clipping at bottom
    const rect = container.getBoundingClientRect();
    const x = event.clientX - rect.left + container.scrollLeft + 15;
    const y = event.clientY - rect.top - tooltip.offsetHeight - 15; // Position above
    tooltip.style.left = `${x}px`;
    tooltip.style.top = `${y}px`;
  }

  function clearSelection() {
    selectedNode = null;

    // Remove all links
    linksGroup.selectAll('line').remove();

    // Remove show markers and time active bar
    showMarkersGroup.selectAll('*').remove();

    // Reset node appearance
    nodesSelection
      .attr('opacity', 1)
      .attr('stroke', '#1a1a1a')
      .attr('stroke-width', 2);

    // Hide panel
    hideArtistPanel();
  }

  function showTooltip(event: MouseEvent, d: TimelineNode) {
    const tooltip = document.getElementById('tooltip');
    const nameEl = document.getElementById('tooltip-name');
    const statsEl = document.getElementById('tooltip-stats');
    if (!tooltip || !nameEl || !statsEl) return;

    nameEl.textContent = d.name;
    statsEl.textContent = `First show: ${d.firstShowDate} • ${d.showCount} shows • ${d.connectionCount} connections`;
    tooltip.classList.remove('hidden');
    moveTooltip(event);
  }

  function moveTooltip(event: MouseEvent) {
    const tooltip = document.getElementById('tooltip');
    const container = document.getElementById('timeline-container');
    if (!tooltip || !container) return;

    const rect = container.getBoundingClientRect();
    // Account for horizontal scroll position
    const x = event.clientX - rect.left + container.scrollLeft + 15;
    const y = event.clientY - rect.top - 10;
    tooltip.style.left = `${x}px`;
    tooltip.style.top = `${y}px`;
  }

  function hideTooltip() {
    const tooltip = document.getElementById('tooltip');
    if (tooltip) tooltip.classList.add('hidden');
  }

  // No longer needed - labels always shown
  function updateLabelsVisibility() {
    // Labels are always visible now
  }

  function dragstarted(event: d3.D3DragEvent<SVGCircleElement, TimelineNode, TimelineNode>, d: TimelineNode) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    // Lock x position to date, only allow y dragging
    d.fx = xScale(new Date(d.firstShowDate));
    d.fy = d.y;
  }

  function dragged(event: d3.D3DragEvent<SVGCircleElement, TimelineNode, TimelineNode>, d: TimelineNode) {
    // Only allow vertical dragging, x is locked to date
    d.fx = xScale(new Date(d.firstShowDate));
    d.fy = event.y;
  }

  function dragended(event: d3.D3DragEvent<SVGCircleElement, TimelineNode, TimelineNode>, d: TimelineNode) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  function showArtistPanel(artist: TimelineNode) {
    const panel = document.getElementById('artist-panel');
    const nameEl = document.getElementById('panel-artist-name');
    const statsEl = document.getElementById('panel-stats');
    const connectionsEl = document.getElementById('panel-connections');

    if (!panel || !nameEl || !statsEl || !connectionsEl) return;

    const getId = (node: any) => typeof node === 'string' ? node : node.id;

    // Build node lookup map
    const nodeMap = new Map<string, TimelineNode>();
    networkData.nodes.forEach((n: TimelineNode) => nodeMap.set(n.id, n));

    // Find connections from actual links
    const connections = networkData.links
      .filter((l: any) => getId(l.source) === artist.id || getId(l.target) === artist.id)
      .map((l: any) => {
        const otherId = getId(l.source) === artist.id ? getId(l.target) : getId(l.source);
        const otherNode = nodeMap.get(otherId);
        return { name: otherNode?.name || 'Unknown', weight: l.weight };
      })
      .sort((a, b) => b.weight - a.weight);

    // Find last show date
    const artistShows = showsData.filter(show =>
      show.artists.some(a => a.id === artist.id)
    );
    const dates = artistShows.map(s => s.date).sort();
    const lastShowDate = dates[dates.length - 1] || artist.firstShowDate;

    nameEl.textContent = artist.name;
    statsEl.innerHTML = `
      <div><span class="text-[#BF0404]">${artist.firstShowDate}</span> First show</div>
      <div><span class="text-[#BF0404]">${lastShowDate}</span> Last show</div>
      <div><span class="text-[#BF0404]">${artist.showCount}</span> total shows</div>
      <div><span class="text-[#BF0404]">${connections.length}</span> connections</div>
    `;

    connectionsEl.innerHTML = connections.map(c => `
      <li class="flex justify-between">
        <span>${c.name}</span>
        <span class="text-gray-500">${c.weight} shows</span>
      </li>
    `).join('');

    panel.classList.remove('translate-x-full');
  }

  function hideArtistPanel() {
    const panel = document.getElementById('artist-panel');
    panel?.classList.add('translate-x-full');
  }

  function searchTimeline(term: string) {
    if (!networkData) return;

    const searchLower = term.toLowerCase();
    const matches = networkData.nodes.filter(n =>
      n.name.toLowerCase().includes(searchLower)
    );

    // Highlight matches
    nodesSelection
      .attr('opacity', (d: any) =>
        term ? (matches.includes(d) ? 1 : 0.2) : 1
      );
  }

  // Initialize
  document.addEventListener('DOMContentLoaded', async () => {
    const [networkDataResult, showsDataResult] = await Promise.all([
      loadNetworkData(),
      loadShowsData()
    ]);

    if (networkDataResult && showsDataResult) {
      showsData = showsDataResult;
      initTimeline(networkDataResult);
    } else {
      const loading = document.getElementById('timeline-loading');
      if (loading) {
        loading.innerHTML = `
          <div class="text-center">
            <p class="text-gray-400 mb-4">Timeline data is being processed.</p>
            <p class="text-gray-500 text-sm">Run the export script to generate the data.</p>
          </div>
        `;
      }
    }

    // Event handlers
    document.getElementById('close-panel')?.addEventListener('click', clearSelection);

    document.getElementById('scroll-to-start')?.addEventListener('click', () => {
      const container = document.getElementById('timeline-container');
      if (container) {
        container.scrollTo({ left: 0, behavior: 'smooth' });
      }
    });

    document.getElementById('scroll-to-end')?.addEventListener('click', () => {
      const container = document.getElementById('timeline-container');
      if (container) {
        container.scrollTo({ left: container.scrollWidth, behavior: 'smooth' });
      }
    });

    const searchInput = document.getElementById('timeline-search') as HTMLInputElement;
    let searchTimeout: number;
    searchInput?.addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      searchTimeout = window.setTimeout(() => {
        searchTimeline((e.target as HTMLInputElement).value);
      }, 300);
    });
  });
</script>
