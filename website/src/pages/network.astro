---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Artist Timeline">
  <section class="px-4 py-8">
    <div class="container mx-auto mb-6">
      <h1 class="text-4xl font-bold text-white mb-4">Artist Timeline & Connections</h1>
      <p class="text-gray-400 mb-6 max-w-2xl">
        Artists positioned by their first show at Velour (2006-2026).
        Circle size represents connection count. Click an artist to see who they've played with.
      </p>

      <!-- Controls -->
      <div class="flex flex-wrap gap-4">
        <input
          type="text"
          id="timeline-search"
          placeholder="Search for an artist..."
          class="search-input max-w-md"
        />
        <button id="reset-view" class="bg-gray-800 hover:bg-gray-700 px-4 py-2 rounded-lg">
          Reset View
        </button>
      </div>
    </div>

    <!-- Timeline Container - Full Width -->
    <div id="timeline-container" class="timeline-container relative w-full" style="background-color: #1a1a1a; min-height: 80vh;">
      <div id="timeline-loading" class="absolute inset-0 flex items-center justify-center">
        <span class="text-gray-400">Loading timeline visualization...</span>
      </div>
      <svg id="timeline-svg" class="w-full h-full" style="display: none;"></svg>
      <!-- Tooltip -->
      <div id="tooltip" class="absolute hidden bg-gray-900 text-white px-3 py-2 rounded-lg text-sm pointer-events-none shadow-lg border border-gray-700 z-50">
        <div id="tooltip-name" class="font-bold"></div>
        <div id="tooltip-stats" class="text-gray-400 text-xs"></div>
      </div>
    </div>

    <!-- Legend -->
    <div class="container mx-auto mt-6">
      <div class="flex flex-wrap gap-6 text-sm text-gray-400">
        <div class="flex items-center gap-2">
          <div class="w-4 h-4 rounded-full bg-[#BF0404]"></div>
          <span>High connection count</span>
        </div>
        <div class="flex items-center gap-2">
          <div class="w-4 h-4 rounded-full bg-[#F20505]"></div>
          <span>Medium connection count</span>
        </div>
        <div class="flex items-center gap-2">
          <div class="w-4 h-4 rounded-full bg-[#F87171]"></div>
          <span>Lower connection count</span>
        </div>
        <div class="flex items-center gap-2">
          <div class="w-3 h-2 bg-[#3B82F6] rounded-sm"></div>
          <span>Show marker (hover for details)</span>
        </div>
      </div>
    </div>
  </section>

  <!-- Artist Details Panel -->
  <div id="artist-panel" class="fixed right-0 top-0 h-full w-80 bg-gray-900 border-l border-gray-800 p-6 transform translate-x-full transition-transform z-50 overflow-y-auto">
    <button id="close-panel" class="absolute top-4 right-4 text-gray-500 hover:text-white">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
      </svg>
    </button>
    <h2 id="panel-artist-name" class="text-2xl font-bold text-white mb-4"></h2>
    <div id="panel-stats" class="space-y-2 text-gray-400 mb-6"></div>
    <h3 class="font-bold text-white mb-2">Connections</h3>
    <ul id="panel-connections" class="space-y-1 text-gray-400 max-h-96 overflow-y-auto"></ul>
  </div>
</Layout>

<script>
  import * as d3 from 'd3';

  interface TimelineNode {
    id: string;
    name: string;
    showCount: number;
    connectionCount: number;
    firstShowDate: string;
    x?: number;
    y?: number;
    fy?: number | null;
  }

  interface TimelineLink {
    source: string | TimelineNode;
    target: string | TimelineNode;
    weight: number;
  }

  interface NetworkData {
    nodes: TimelineNode[];
    links: TimelineLink[];
  }

  interface Show {
    id: string;
    date: string;
    title: string;
    genre?: string;
    eventType: string;
    artists: Array<{id: string; name: string; isHeadliner: boolean}>;
    soldOut: boolean;
    ticketPrice?: string;
  }

  let simulation: d3.Simulation<TimelineNode, TimelineLink>;
  let svg: d3.Selection<SVGSVGElement, unknown, HTMLElement, any>;
  let networkData: NetworkData;
  let showsData: Show[] = [];
  let currentZoom = 1;
  let labelsGroup: d3.Selection<SVGGElement, unknown, HTMLElement, any>;
  let linksGroup: d3.Selection<SVGGElement, unknown, HTMLElement, any>;
  let showMarkersGroup: d3.Selection<SVGGElement, unknown, HTMLElement, any>;
  let nodesSelection: d3.Selection<SVGCircleElement, TimelineNode, SVGGElement, unknown>;
  let selectedNode: TimelineNode | null = null;
  let xScale: d3.ScaleTime<number, number>;
  let margin: {top: number; right: number; bottom: number; left: number};

  async function loadNetworkData(): Promise<NetworkData | null> {
    try {
      const response = await fetch('/data/network.json');
      if (response.ok) {
        return await response.json();
      }
    } catch (e) {
      console.error('Failed to load network data:', e);
    }
    return null;
  }

  async function loadShowsData(): Promise<Show[] | null> {
    try {
      const response = await fetch('/data/shows.json');
      if (response.ok) {
        return await response.json();
      }
    } catch (e) {
      console.error('Failed to load shows data:', e);
    }
    return null;
  }

  function initTimeline(data: NetworkData) {
    const container = document.getElementById('timeline-container');
    const loading = document.getElementById('timeline-loading');
    const svgElement = document.getElementById('timeline-svg') as SVGSVGElement;

    if (!container || !svgElement) return;

    loading?.remove();
    svgElement.style.display = 'block';

    const width = container.clientWidth;
    const height = Math.max(container.clientHeight, window.innerHeight * 0.8);
    margin = { top: 40, right: 40, bottom: 60, left: 40 };
    const innerWidth = width - margin.left - margin.right;
    const innerHeight = height - margin.top - margin.bottom;

    // Clear existing
    svgElement.innerHTML = '';

    svg = d3.select(svgElement)
      .attr('viewBox', [0, 0, width, height]);

    // Filter nodes to only those with a valid first show date between 2006-2026
    const validNodes = data.nodes.filter(n => {
      if (!n.firstShowDate) return false;
      const year = parseInt(n.firstShowDate.substring(0, 4));
      return year >= 2006 && year <= 2026;
    });

    // Create time scale for x-axis (2006 to 2026)
    const minDate = new Date('2006-01-01');
    const maxDate = new Date('2026-12-31');

    xScale = d3.scaleTime()
      .domain([minDate, maxDate])
      .range([margin.left, width - margin.right]);

    // Set initial x positions based on first show date
    validNodes.forEach(node => {
      node.x = xScale(new Date(node.firstShowDate));
      node.y = innerHeight / 2 + margin.top; // Start in middle
    });

    // Add zoom behavior
    const g = svg.append('g');

    const zoom = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.5, 10])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
        currentZoom = event.transform.k;
        updateLabelsVisibility();
      });

    svg.call(zoom);

    // Scale for node size based on connection count
    const sizeScale = d3.scaleSqrt()
      .domain([1, d3.max(validNodes, d => d.connectionCount) || 50])
      .range([4, 25]);

    // Color scale based on connection count
    const colorScale = d3.scaleSequential()
      .domain([0, d3.max(validNodes, d => d.connectionCount) || 50])
      .interpolator(t => d3.interpolateRgb('#F87171', '#BF0404')(t));

    // Create simulation with collision detection on Y-axis only
    // X positions are locked to the timeline date
    simulation = d3.forceSimulation(validNodes)
      .force('x', d3.forceX<TimelineNode>(d => xScale(new Date(d.firstShowDate))).strength(1))
      .force('y', d3.forceY<TimelineNode>().y(innerHeight / 2 + margin.top).strength(0.02))
      .force('collision', d3.forceCollide<TimelineNode>().radius(d => sizeScale(d.connectionCount) + 2).iterations(3))
      .alphaDecay(0.01);

    // Draw timeline axis
    const xAxis = d3.axisBottom(xScale)
      .ticks(d3.timeYear.every(2))
      .tickFormat(d => d3.timeFormat('%Y')(d as Date));

    g.append('g')
      .attr('class', 'x-axis')
      .attr('transform', `translate(0, ${height - margin.bottom})`)
      .call(xAxis)
      .attr('color', '#666')
      .selectAll('text')
      .attr('fill', '#999');

    // Add grid lines for years
    g.append('g')
      .attr('class', 'grid')
      .selectAll('line')
      .data(d3.timeYear.range(minDate, maxDate, 1))
      .join('line')
      .attr('x1', d => xScale(d))
      .attr('x2', d => xScale(d))
      .attr('y1', margin.top)
      .attr('y2', height - margin.bottom)
      .attr('stroke', '#333')
      .attr('stroke-width', 0.5)
      .attr('stroke-dasharray', '2,2');

    // Create empty links group
    linksGroup = g.append('g').attr('class', 'links');

    // Create show markers group (below nodes)
    showMarkersGroup = g.append('g').attr('class', 'show-markers');

    // Draw nodes
    nodesSelection = g.append('g')
      .selectAll('circle')
      .data(validNodes)
      .join('circle')
      .attr('r', d => sizeScale(d.connectionCount))
      .attr('fill', d => colorScale(d.connectionCount))
      .attr('stroke', '#1a1a1a')
      .attr('stroke-width', 2)
      .attr('class', 'artist-node')
      .attr('cursor', 'pointer')
      .call(d3.drag<SVGCircleElement, TimelineNode>()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended))
      .on('click', (event, d) => {
        event.stopPropagation();
        selectNode(d);
      })
      .on('mouseover', function(event, d) {
        d3.select(this).attr('stroke', '#F0F0F0').attr('stroke-width', 3);
        showTooltip(event, d);
      })
      .on('mousemove', function(event, d) {
        moveTooltip(event);
      })
      .on('mouseout', function() {
        d3.select(this).attr('stroke', '#1a1a1a').attr('stroke-width', 2);
        hideTooltip();
      });

    // Add text labels (shown on zoom)
    labelsGroup = g.append('g').attr('class', 'labels');
    labelsGroup.selectAll('text')
      .data(validNodes)
      .join('text')
      .attr('text-anchor', 'middle')
      .attr('dy', d => -sizeScale(d.connectionCount) - 6)
      .attr('font-size', '11px')
      .attr('fill', '#e5e5e5')
      .attr('pointer-events', 'none')
      .attr('opacity', 0)
      .text(d => d.name);

    // Update positions on tick (only Y changes, X is fixed by date)
    simulation.on('tick', () => {
      // Update link positions if any are drawn
      linksGroup.selectAll('line')
        .attr('x1', (d: any) => d.source.x)
        .attr('y1', (d: any) => d.source.y)
        .attr('x2', (d: any) => d.target.x)
        .attr('y2', (d: any) => d.target.y);

      nodesSelection
        .attr('cx', d => d.x!)
        .attr('cy', d => d.y!);

      labelsGroup.selectAll('text')
        .attr('x', (d: any) => d.x)
        .attr('y', (d: any) => d.y);
    });

    networkData = { nodes: validNodes, links: data.links };

    // Click on background to deselect
    svg.on('click', () => {
      clearSelection();
    });
  }

  function selectNode(artist: TimelineNode) {
    // If clicking same node, deselect
    if (selectedNode?.id === artist.id) {
      clearSelection();
      return;
    }

    selectedNode = artist;

    // Helper to get ID from source/target
    const getId = (node: any) => typeof node === 'string' ? node : node.id;

    // Find all connections for this artist
    const artistLinks = networkData.links.filter((l: any) =>
      getId(l.source) === artist.id || getId(l.target) === artist.id
    );

    // Get connected node IDs
    const connectedIds = new Set<string>();
    connectedIds.add(artist.id);
    artistLinks.forEach((l: any) => {
      connectedIds.add(getId(l.source));
      connectedIds.add(getId(l.target));
    });

    // Build a map of node positions
    const nodeMap = new Map<string, TimelineNode>();
    nodesSelection.data().forEach((n: TimelineNode) => nodeMap.set(n.id, n));

    // Draw links for selected node
    linksGroup.selectAll('line').remove();
    linksGroup.selectAll('line')
      .data(artistLinks)
      .join('line')
      .attr('stroke', '#BF0404')
      .attr('stroke-opacity', 0.4)
      .attr('stroke-width', (d: any) => Math.max(1, Math.sqrt(d.weight)))
      .attr('x1', (d: any) => nodeMap.get(getId(d.source))?.x || 0)
      .attr('y1', (d: any) => nodeMap.get(getId(d.source))?.y || 0)
      .attr('x2', (d: any) => nodeMap.get(getId(d.target))?.x || 0)
      .attr('y2', (d: any) => nodeMap.get(getId(d.target))?.y || 0);

    // Draw show markers for this artist
    drawShowMarkers(artist);

    // Dim non-connected nodes
    nodesSelection
      .attr('opacity', (d: TimelineNode) => connectedIds.has(d.id) ? 1 : 0.2)
      .attr('stroke', (d: TimelineNode) => d.id === artist.id ? '#F0F0F0' : '#1a1a1a')
      .attr('stroke-width', (d: TimelineNode) => d.id === artist.id ? 3 : 2);

    // Show artist panel
    showArtistPanel(artist);
  }

  function drawShowMarkers(artist: TimelineNode) {
    // Find all shows for this artist
    const artistShows = showsData.filter(show =>
      show.artists.some(a => a.id === artist.id)
    );

    // Clear existing markers
    showMarkersGroup.selectAll('rect').remove();

    // Draw a small rectangle for each show
    const markerHeight = 8;
    const markerWidth = 3;
    const container = document.getElementById('timeline-container');
    const height = Math.max(container?.clientHeight || 0, window.innerHeight * 0.8);
    const yPosition = height - margin.bottom - markerHeight - 5; // Just above the date axis

    showMarkersGroup.selectAll('rect')
      .data(artistShows)
      .join('rect')
      .attr('x', (d: Show) => xScale(new Date(d.date)) - markerWidth / 2)
      .attr('y', yPosition)
      .attr('width', markerWidth)
      .attr('height', markerHeight)
      .attr('fill', '#3B82F6')
      .attr('opacity', 0.7)
      .attr('rx', 1)
      .style('cursor', 'pointer')
      .on('mouseover', function(event, d: Show) {
        d3.select(this).attr('opacity', 1).attr('fill', '#60A5FA');
        showShowTooltip(event, d);
      })
      .on('mousemove', function(event) {
        moveTooltip(event);
      })
      .on('mouseout', function() {
        d3.select(this).attr('opacity', 0.7).attr('fill', '#3B82F6');
        hideTooltip();
      });
  }

  function showShowTooltip(event: MouseEvent, show: Show) {
    const tooltip = document.getElementById('tooltip');
    const nameEl = document.getElementById('tooltip-name');
    const statsEl = document.getElementById('tooltip-stats');
    if (!tooltip || !nameEl || !statsEl) return;

    const artistNames = show.artists.map(a => a.name).join(', ');
    nameEl.textContent = show.title;
    statsEl.innerHTML = `
      <div>${show.date}</div>
      <div>${artistNames}</div>
      ${show.genre ? `<div>Genre: ${show.genre}</div>` : ''}
      ${show.ticketPrice ? `<div>Price: ${show.ticketPrice}</div>` : ''}
      ${show.soldOut ? '<div class="text-red-400">SOLD OUT</div>' : ''}
    `;
    tooltip.classList.remove('hidden');
    moveTooltip(event);
  }

  function clearSelection() {
    selectedNode = null;

    // Remove all links
    linksGroup.selectAll('line').remove();

    // Remove show markers
    showMarkersGroup.selectAll('rect').remove();

    // Reset node appearance
    nodesSelection
      .attr('opacity', 1)
      .attr('stroke', '#1a1a1a')
      .attr('stroke-width', 2);

    // Hide panel
    hideArtistPanel();
  }

  function showTooltip(event: MouseEvent, d: TimelineNode) {
    const tooltip = document.getElementById('tooltip');
    const nameEl = document.getElementById('tooltip-name');
    const statsEl = document.getElementById('tooltip-stats');
    if (!tooltip || !nameEl || !statsEl) return;

    nameEl.textContent = d.name;
    statsEl.textContent = `First show: ${d.firstShowDate} • ${d.showCount} shows • ${d.connectionCount} connections`;
    tooltip.classList.remove('hidden');
    moveTooltip(event);
  }

  function moveTooltip(event: MouseEvent) {
    const tooltip = document.getElementById('tooltip');
    const container = document.getElementById('timeline-container');
    if (!tooltip || !container) return;

    const rect = container.getBoundingClientRect();
    const x = event.clientX - rect.left + 15;
    const y = event.clientY - rect.top - 10;
    tooltip.style.left = `${x}px`;
    tooltip.style.top = `${y}px`;
  }

  function hideTooltip() {
    const tooltip = document.getElementById('tooltip');
    if (tooltip) tooltip.classList.add('hidden');
  }

  function updateLabelsVisibility() {
    if (!labelsGroup) return;
    const showLabels = currentZoom >= 1.5;
    labelsGroup.selectAll('text')
      .attr('opacity', showLabels ? 1 : 0)
      .attr('font-size', `${11 / currentZoom}px`);
  }

  function dragstarted(event: d3.D3DragEvent<SVGCircleElement, TimelineNode, TimelineNode>, d: TimelineNode) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    // Lock x position to date, only allow y dragging
    d.fx = xScale(new Date(d.firstShowDate));
    d.fy = d.y;
  }

  function dragged(event: d3.D3DragEvent<SVGCircleElement, TimelineNode, TimelineNode>, d: TimelineNode) {
    // Only allow vertical dragging, x is locked to date
    d.fx = xScale(new Date(d.firstShowDate));
    d.fy = event.y;
  }

  function dragended(event: d3.D3DragEvent<SVGCircleElement, TimelineNode, TimelineNode>, d: TimelineNode) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  function showArtistPanel(artist: TimelineNode) {
    const panel = document.getElementById('artist-panel');
    const nameEl = document.getElementById('panel-artist-name');
    const statsEl = document.getElementById('panel-stats');
    const connectionsEl = document.getElementById('panel-connections');

    if (!panel || !nameEl || !statsEl || !connectionsEl) return;

    const getId = (node: any) => typeof node === 'string' ? node : node.id;

    // Build node lookup map
    const nodeMap = new Map<string, TimelineNode>();
    networkData.nodes.forEach((n: TimelineNode) => nodeMap.set(n.id, n));

    // Find connections from actual links
    const connections = networkData.links
      .filter((l: any) => getId(l.source) === artist.id || getId(l.target) === artist.id)
      .map((l: any) => {
        const otherId = getId(l.source) === artist.id ? getId(l.target) : getId(l.source);
        const otherNode = nodeMap.get(otherId);
        return { name: otherNode?.name || 'Unknown', weight: l.weight };
      })
      .sort((a, b) => b.weight - a.weight);

    nameEl.textContent = artist.name;
    statsEl.innerHTML = `
      <div><span class="text-[#BF0404]">${artist.firstShowDate}</span> First show</div>
      <div><span class="text-[#BF0404]">${artist.showCount}</span> total shows</div>
      <div><span class="text-[#BF0404]">${connections.length}</span> connections</div>
    `;

    connectionsEl.innerHTML = connections.map(c => `
      <li class="flex justify-between">
        <span>${c.name}</span>
        <span class="text-gray-500">${c.weight} shows</span>
      </li>
    `).join('');

    panel.classList.remove('translate-x-full');
  }

  function hideArtistPanel() {
    const panel = document.getElementById('artist-panel');
    panel?.classList.add('translate-x-full');
  }

  function searchTimeline(term: string) {
    if (!networkData) return;

    const searchLower = term.toLowerCase();
    const matches = networkData.nodes.filter(n =>
      n.name.toLowerCase().includes(searchLower)
    );

    // Highlight matches
    nodesSelection
      .attr('opacity', (d: any) =>
        term ? (matches.includes(d) ? 1 : 0.2) : 1
      );
  }

  // Initialize
  document.addEventListener('DOMContentLoaded', async () => {
    const [networkDataResult, showsDataResult] = await Promise.all([
      loadNetworkData(),
      loadShowsData()
    ]);

    if (networkDataResult && showsDataResult) {
      showsData = showsDataResult;
      initTimeline(networkDataResult);
    } else {
      const loading = document.getElementById('timeline-loading');
      if (loading) {
        loading.innerHTML = `
          <div class="text-center">
            <p class="text-gray-400 mb-4">Timeline data is being processed.</p>
            <p class="text-gray-500 text-sm">Run the export script to generate the data.</p>
          </div>
        `;
      }
    }

    // Event handlers
    document.getElementById('close-panel')?.addEventListener('click', clearSelection);
    document.getElementById('reset-view')?.addEventListener('click', () => {
      svg.transition().duration(500).call(
        d3.zoom<SVGSVGElement, unknown>().transform as any,
        d3.zoomIdentity
      );
    });

    const searchInput = document.getElementById('timeline-search') as HTMLInputElement;
    let searchTimeout: number;
    searchInput?.addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      searchTimeout = window.setTimeout(() => {
        searchTimeline((e.target as HTMLInputElement).value);
      }, 300);
    });
  });
</script>
